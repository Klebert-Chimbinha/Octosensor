//Deixa a fita de Led Respirar atraves da medição de Millis
#include <FastLED.h>

#define NUM_LEDS 30
#define LED_PIN 5
#define LED_TYPE    WS2812

unsigned long int respira = 0;
int r = 0;
int e = NUM_LEDS - 1;
int estado = 2;

CRGB leds[NUM_LEDS];

CRGBPalette16 currentPalette;
TBlendType    currentBlending;

void setup () {
  FastLED.addLeds<LED_TYPE, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(250);
  
  currentPalette = RainbowColors_p;
  currentBlending = LINEARBLEND;
  }

void loop() {
  //int proximo = map(analogRead(A0),1023, 0, 1000, 10);
  //if(proximo <= 1000){
    //estado = 1;
  //}
//Respiração Básica
  if(estado == 0){
    Respirando(50, 50);
  }
//Pessoa entra no perimetro
  if(estado == 1){
    Piscalerta(100,100);
  }
//Pessoa se aproxima e a respiração varia
  if(estado == 2){
  //trigged(proximo, proximo*0.7);
    trigged(50,50);
    }
//Pacifica
  if(estado == 3){
    pacifica_loop(255, 145, 200);
    FastLED.show();
    }
}
void Respirando( int inspira, int expira) {
  if(r < NUM_LEDS){
    if(millis() - respira >= inspira){
      Arcoiris(r);
      blur1d(leds, NUM_LEDS, 10);
      FastLED.show();
      respira += inspira;
      r += 1;
      }
    }
    if(r == NUM_LEDS){
      if(millis() - respira >= expira){
        leds[e] = CRGB::Black;
        //blur1d(leds, NUM_LEDS, 15);
        fadeToBlackBy(leds, NUM_LEDS, 24);
        FastLED.show();
        respira += expira;
        e -= 1;
        }
      }
      if(r == NUM_LEDS and e == 0){
        r = 0;
        e = NUM_LEDS - 1;
      }
  } 
//Engatilhado
void Piscalerta( int inspira, int expira) {
  if(r < NUM_LEDS){
    if(millis() - respira >= inspira){
      fill_solid( leds, NUM_LEDS, CRGB::Red);
      FastLED.show();
      respira += inspira;
      r += 1;
      }
    if(millis() - respira >= expira){
        FastLED.clear();
        //fadeToBlackBy(leds, NUM_LEDS, 170);
        FastLED.show();
        respira += expira;
        e -= 1;
      }
    }
    if(r == NUM_LEDS){
      if(millis() - respira >= expira){
        fill_solid( leds, NUM_LEDS, CRGB::Red);
        FastLED.show();
        respira += expira;
        e -= 1;
      }
      }
      if(r == NUM_LEDS and e == 0){
        FastLED.clear();
        FastLED.show();
        e = NUM_LEDS - 1;
        r = 0;
        estado += 1;
      }
  }

void trigged(int inspira, int expira){
   if(r < NUM_LEDS){
    if(millis() - respira >= inspira){
      leds[r] = CRGB::Red;
      FastLED.show();
      respira += inspira;
      r += 1;
      }
    }
    if(r == NUM_LEDS){
      if(millis() - respira >= expira){
        leds[e] = CRGB::Black;
        FastLED.show();
        respira += expira;
        e -= 1;
        }
      }
      if(r == NUM_LEDS and e == 0){
        r = 0;
        e = NUM_LEDS - 1;
      }
  } 

void Arcoiris(int r ){
  int intervalo = NUM_LEDS/7;
  if(r + 1 <= intervalo){

    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 1000, 255, currentBlending);   //leds[r] = CRGB::Violet;
  }else if(r + 1 <= 2*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 7000, 255, currentBlending);    //leds[r] = CRGB::Indigo;
  }else if(r + 1 <= 3*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 6000, 255, currentBlending);      //leds[r] = CRGB::Cyan;
  }else if(r + 1 <= 4*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 5000, 255, currentBlending);     // leds[r] = CRGB::Green;
  }else if (r + 1 <= 5*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 4000, 255, currentBlending);     // leds[r] = CRGB::Yellow;
  }else if (r + 1 <= 6*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 3000, 255, currentBlending);      //leds[r] = CRGB::Orange;
  }else if(r + 1 <= 7*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 2000, 255, currentBlending);      //leds[r] = CRGB::Red;
  }else if( r + 1 >= 7*intervalo){
    SetupArcoirisPalette();
    leds[r] = ColorFromPalette( currentPalette, 1000, 255, currentBlending);       //leds[r] = CRGB::Violet;
  }
  }

void SetupArcoirisPalette(){
 
 CRGB::Yellow;
 CRGB::Orange;
 CRGB::Red;
  CRGB violet = CRGB::Violet;
  CRGB indigo = CRGB::Indigo;
  CRGB cyan = CRGB::Cyan;
  CRGB green = CRGB::Green;
  CRGB yellow  = CRGB::Yellow;
  CRGB orange = CRGB::Orange;
  CRGB red = CRGB::Red;

  currentPalette = CRGBPalette16(
                     violet,  violet,  indigo,  indigo,
                     cyan, cyan, green,  green,
                     yellow,  yellow,  orange,  orange,
                     red, red, violet,  violet );
  }

//Pacifica
CRGBPalette16 pacifica_palette_1 = 
    { 0x000507, 0x000409, 0x00030B, 0x00030D, 0x000210, 0x000212, 0x000114, 0x000117, 
      0x000019, 0x00001C, 0x000026, 0x000031, 0x00003B, 0x000046, 0x14554B, 0x28AA50 };
CRGBPalette16 pacifica_palette_2 = 
    { 0x000507, 0x000409, 0x00030B, 0x00030D, 0x000210, 0x000212, 0x000114, 0x000117, 
      0x000019, 0x00001C, 0x000026, 0x000031, 0x00003B, 0x000046, 0x0C5F52, 0x19BE5F };
CRGBPalette16 pacifica_palette_3 = 
    { 0x000208, 0x00030E, 0x000514, 0x00061A, 0x000820, 0x000927, 0x000B2D, 0x000C33, 
      0x000E39, 0x001040, 0x001450, 0x001860, 0x001C70, 0x002080, 0x1040BF, 0x2060FF };


void pacifica_loop(uint8_t brg, int Sat1, int Sat2){
  static uint16_t sCIStart1, sCIStart2, sCIStart3, sCIStart4;
  static uint32_t sLastms = 0;
  uint32_t ms = GET_MILLIS();
  uint32_t deltams = ms - sLastms;
  sLastms = ms;
  uint16_t speedfactor1 = beatsin16(3, 179, 269);
  uint16_t speedfactor2 = beatsin16(4, 179, 269);
  uint32_t deltams1 = (deltams * speedfactor1) / 256;
  uint32_t deltams2 = (deltams * speedfactor2) / 256;
  uint32_t deltams21 = (deltams1 + deltams2) / 2;
  sCIStart1 += (deltams1 * beatsin88(1011,10,13));
  sCIStart2 -= (deltams21 * beatsin88(777,8,11));
  sCIStart3 -= (deltams1 * beatsin88(501,5,7));
  sCIStart4 -= (deltams2 * beatsin88(257,4,6));

  fill_solid( leds, NUM_LEDS, CRGB( 2, 6, 10));

  pacifica_one_layer( pacifica_palette_1, sCIStart1, beatsin16( 3, 11 * 256, 14 * 256), brg, 0-beat16( 301) );
  pacifica_one_layer( pacifica_palette_2, sCIStart2, beatsin16( 4,  6 * 256,  9 * 256), brg, beat16( 401) );
  pacifica_one_layer( pacifica_palette_3, sCIStart3, 6 * 256, brg, 0-beat16(503));
  pacifica_one_layer( currentPalette, sCIStart4, 5 * 256, brg, beat16(601));

  pacifica_add_whitecaps();

  pacifica_deepen_colors( Sat1, Sat2);
  }

void pacifica_one_layer( CRGBPalette16& p, uint16_t cistart, uint16_t wavescale, uint8_t bri, uint16_t ioff){
  uint16_t ci = cistart;
  uint16_t waveangle = ioff;
  uint16_t wavescale_half = (wavescale / 2) + 20;
  for( uint16_t i = 0; i < NUM_LEDS; i++) {
    waveangle += 250;
    uint16_t s16 = sin16( waveangle ) + 32768;
    uint16_t cs = scale16( s16 , wavescale_half ) + wavescale_half;
    ci += cs;
    uint16_t sindex16 = sin16( ci) + 32768;
    uint8_t sindex8 = scale16( sindex16, 240);
    CRGB c = ColorFromPalette( p, sindex8, bri, LINEARBLEND);
    leds[i] += c;
  }
  }

void pacifica_add_whitecaps(){
  uint8_t basethreshold = beatsin8( 9, 55, 65);
  uint8_t wave = beat8( 7 );
  
  for( uint16_t i = 0; i < NUM_LEDS; i++) {
    uint8_t threshold = scale8( sin8( wave), 20) + basethreshold;
    wave += 7;
    uint8_t l = leds[i].getAverageLight();
    if( l > threshold) {
      uint8_t overage = l - threshold;
      uint8_t overage2 = qadd8( overage, overage);
      leds[i] += CRGB( overage, overage2, qadd8( overage2, overage2));
    }
  }
  }

void pacifica_deepen_colors(int Sat1, int Sat2){
  for( uint16_t i = 0; i < NUM_LEDS; i++) {
    leds[i].blue = scale8( leds[i].blue,  Sat1); //145 
    leds[i].green= scale8( leds[i].green, Sat2); //200
    leds[i] |= CRGB( 2, 5, 7);
  }
  }
//  "Pacifica"
//  Gentle, blue-green ocean waves.
//  December 2019, Mark Kriegsman and Mary Corey March.
//  For Dan.
//
